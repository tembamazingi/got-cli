# List all custom functions
.fn () {

  print -l ${(ok)functions[(I).*]}

}
# Archives - create new
.fn:a () {
  if [ "$#" -lt 2 ] ; then
    echo "usage: .fn:a [archive_file] [files/folders...]"
    return 1
  fi
  
  FILE="$1"
  shift
  
  # Check if source files exist
  for item in "$@"; do
    if [ ! -e "$item" ]; then
      echo "Error: '$item' does not exist"
      return 1
    fi
  done
  
  case "$FILE" in
    *.tar.bz2|*.tbz2) tar cvjf "$FILE" "$@" ;;
    *.tar.gz|*.tgz)   tar cvzf "$FILE" "$@" ;;
    *.tar)            tar cvf "$FILE" "$@" ;;
    *.zip)            zip -r "$FILE" "$@" ;;
    *.rar)            rar a "$FILE" "$@" ;;
    *.7z)             7z a "$FILE" "$@" ;;
    *)                echo "'$FILE' format not supported" ;;
  esac
}

# Archives - Extract
.fn:a:x () {

  if [ $# -lt 1 ]
  then
    echo Usage: extract file
    return 1
  fi
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xvjf $1    ;;
      *.tar.gz)    tar xvzf $1    ;;
      *.bz2)       bunzip2 $1     ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1      ;;
      *.tar)       tar xvf $1     ;;
      *.tbz2)      tar xvjf $1    ;;
      *.tgz)       tar xvzf $1    ;;
      *.zip)       unzip $1       ;;
      *.war|*.jar) unzip $1       ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1        ;;
      *)           echo "don't know how to extract '$1'..." ;;
    esac
  else
    echo "'$1' is not a valid file!"
  fi

}

# Files/Folders: Make folder and enter
.fn:d (){

  if [ -f "$1" ] ; then
    echo "File $1 exists~"
    return
  fi
  if [ ! -d "$1" ] ;then
    mkdir -p "$1"
    cd "$1"
  else
    echo "$1 exists~"
  fi

}

# Git - config
.fn:g:cnf () {

  git config --global user.name "$1" && git config --global user.email "$2"

}

# Git - link local repo to remote origin
.fn:g:ro () {

  git remote add origin "$1" && git branch -M main && git push -u origin main

}

# Git: Revert both the local and remote to a previous working commit.
.fn:g:rv ()
{

  git reset --hard $1 && git clean -f && git push -f origin $2

}

# Git: What changed in the last X days?
.fn:g:wch ()
{

  git whatchanged --abbrev-commit --since="$1"

}




# Git: create local tracking branches for all untracked remote branches.
.fn:g:br. () {

  remote=origin;

  # Get all remote branches
  remote_branches=$(git branch -r | grep $remote | grep -v /main | grep -v /HEAD | awk '{gsub(/^[^\/]+\//,"",$1); print $1}')
    
  for brname in $remote_branches; do
    # Check if branch already exists locally   
    if ! git show-ref -q --heads $brname; then
      echo "Tracking remote branch: $brname"
      git branch --track $brname $remote/$brname
      echo "Checking out and pulling branch: $brname"
      git checkout $brname && git pull
    else
      echo "Branch $brname already exists locally."
    fi
  done
  
  # Return to master branch
  echo "Returning to master branch"
  git checkout master
}

# Git: Find files in the repository that are redundant and not referenced anywhere in the application's code.
.fn:g:clean () {

  # Loop through all files in the specified directory
  for FILE in $(git ls-files ./$1); do
      # Check if the file is referenced anywhere in the application's code
      git grep $(basename "$FILE") > /dev/null || echo "$FILE is not referenced anywhere in the application's code and can probably be removed."
  done

}

# Git: Delete stale branches that have already been merged into the main branch.
.fn:g:clean:br () {

  for k in $(git branch --format="%(refname:short)" --merged main); do
    if [[ $(git log -1 --since='9 months ago' -s $k |wc -l)==0 ]]; then
      git log -1 --date=relative --oneline --pretty="%C(red)[Date: %ad]%C(cyan) <=> Last Commit: %C(yellow)%s" $k
    fi
  done

}

# Function to manage git stashes
function .fn:g:stash() {
    action=$1
    case "$action" in
        "s") git stash ;;
        "a") git stash apply ;;
        "c") git stash clear ;;
        "l") git stash list ;;
        *) echo "Invalid action. Available actions: 's' <=> save, 'a' <=> apply, 'c' <=> clear, 'l' <=> list" ;;
    esac
}

# Function to manage git remotes
function .fn:g:remote() {
    action=$1
    case "$action" in
        "v") git remote -v ;;
        "a") git remote add origin ;;
        "p") git remote prune origin ;;
        "r") git remote remove origin ;;
        *) echo "Invalid action. Available actions: 'v' <=> show, 'a' <=> add, 'p' <=> prune, 'r' <=> remove" ;;
    esac
}

function .fn:g:branch() {
  local branch_name="$1"
  local remote_branch="${2:-local}" # Default to local if not specified

  if [ -z "$branch_name" ]; then
    echo "Usage: .fn:g:branch <branch_name> [remote_branch (default: local)]"
    return 1
  fi

  git checkout -b "$branch_name"

  if [ "$remote_branch" != "local" ]; then
    git push origin "HEAD:$branch_name"
    git branch --set-upstream-to=origin/"$branch_name" "$branch_name"
  fi
}

# Convert .mov files to .mp4 files
function .fn:c:mp4() {
    for input_file in *.mov; do
        if [ -f "$input_file" ]; then
            output_file="${input_file%.mov}.mp4"
            ffmpeg -i "$input_file" -c:v libx264 -c:a aac -vf format=yuv420p -movflags +faststart "$output_file"
        fi
    done
}

# Port management: view/kill/force kill processes running on a specified port
function .fn:pm() {
    if [ -z "$1" ]; then
        echo "Usage: .fn:pm <port_number> [action]"
        echo "Actions:"
        echo "  c  - Just check what's running (default)"
        echo "  k   - Kill with confirmation"
        echo "  z  - Force kill without confirmation"
        echo ""
        echo "Examples:"
        echo "  .fn:pm 3000"
        echo "  .fn:pm 3000 c"
        echo "  .fn:pm 3000 k"
        return 1
    fi
    
    local port=$1
    local action=${2:-c}
    
    # Check if lsof is available
    if ! command -v lsof &> /dev/null; then
        echo "Error: lsof command not found. Please install it first."
        return 1
    fi
    
    echo "Checking port $port..."
    
    # Find processes using the port
    local pids=$(lsof -ti:$port)
    
    if [ -z "$pids" ]; then
        echo "‚úÖ No process found running on port $port"
        return 0
    fi
    
    # Display process information
    echo "üîç Process(es) found on port $port:"
    echo "----------------------------------------"
    lsof -i:$port
    echo "----------------------------------------"
    
    # Handle different actions
    case $action in
        "c")
            echo "‚ÑπÔ∏è  Use '.fn:pm $port k' to terminate these processes"
            ;;
        "k"|"z")
            for pid in $pids; do
                # Get process info
                local process_info=$(ps -p $pid -o user=,comm= 2>/dev/null)
                local process_user=$(echo "$process_info" | awk '{print $1}')
                local process_name=$(echo "$process_info" | awk '{print $2}')
                local current_user=$(whoami)
                
                if [ -z "$process_info" ]; then
                    echo "‚ö†Ô∏è  Process $pid no longer exists"
                    continue
                fi
                
                echo "üìã Process $pid: $process_name (owner: $process_user)"
                
                # Check permissions
                if [ "$process_user" != "$current_user" ] && [ "$current_user" != "root" ]; then
                    echo "‚ö†Ô∏è  Warning: Process $pid is owned by $process_user, not $current_user"
                    echo "   You may need sudo permissions to terminate this process"
                fi
                
                if [ "$action" = "k" ]; then
                    read -p "‚ùì Terminate process $pid ($process_name)? [y/N]: " -n 1 -r
                    echo ""
                    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                        echo "‚è≠Ô∏è  Skipping process $pid"
                        continue
                    fi
                fi
                
                echo "üîÑ Terminating process $pid ($process_name)..."
                
                # Try graceful termination first
                local need_sudo=false
                if kill "$pid" 2>/dev/null; then
                    echo "   Sent SIGTERM to process $pid"
                    sleep 2  # Give more time for graceful shutdown
                    
                    if kill -0 "$pid" 2>/dev/null; then
                        echo "üîÑ Process still running, force killing process $pid..."
                        if kill -9 "$pid" 2>/dev/null; then
                            echo "   Sent SIGKILL to process $pid"
                            sleep 1
                            if kill -0 "$pid" 2>/dev/null; then
                                echo "‚ùå Failed to terminate process $pid (process may be unkillable)"
                            else
                                echo "‚úÖ Process $pid forcefully terminated"
                            fi
                        else
                            need_sudo=true
                        fi
                    else
                        echo "‚úÖ Process $pid terminated successfully"
                    fi
                else
                    need_sudo=true
                fi
                
                # Try with sudo if regular kill failed
                if [ "$need_sudo" = true ]; then
                    echo "üîê Attempting to terminate process $pid with elevated privileges..."
                    if sudo kill "$pid" 2>/dev/null; then
                        echo "   Sent SIGTERM to process $pid (with sudo)"
                        sleep 2
                        
                        if kill -0 "$pid" 2>/dev/null; then
                            echo "üîÑ Process still running, force killing with sudo..."
                            if sudo kill -9 "$pid" 2>/dev/null; then
                                echo "   Sent SIGKILL to process $pid (with sudo)"
                                sleep 1
                                if kill -0 "$pid" 2>/dev/null; then
                                    echo "‚ùå Failed to terminate process $pid (process may be unkillable)"
                                else
                                    echo "‚úÖ Process $pid forcefully terminated (with sudo)"
                                fi
                            else
                                echo "‚ùå Failed to force kill process $pid even with sudo"
                            fi
                        else
                            echo "‚úÖ Process $pid terminated successfully (with sudo)"
                        fi
                    else
                        echo "‚ùå Failed to terminate process $pid even with sudo"
                        echo "   Process may be unkillable or in an uninterruptible state"
                    fi
                fi
            done
            
            # Final verification
            echo ""
            echo "üîç Final verification:"
            local remaining=$(lsof -ti:$port)
            if [ -z "$remaining" ]; then
                echo "‚úÖ Port $port is now free!"
            else
                echo "‚ö†Ô∏è  Some processes still running on port $port:"
                lsof -i:$port
                echo ""
                echo "üí° Some processes may be unkillable if they're in an uninterruptible state"
            fi
            ;;
        *)
            echo "‚ùå Unknown action: $action"
            echo "Valid actions: c, k, z"
            return 1
            ;;
    esac
}