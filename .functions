# List all custom functions
.fn () {

  print -l ${(ok)functions[(I).*]}

}
# Archives - create new
.fn:a () {
  if [ "$#" -lt 2 ] ; then
    echo "usage: .fn:a [archive_file] [files/folders...]"
    return 1
  fi
  
  FILE="$1"
  shift
  
  # Check if source files exist
  for item in "$@"; do
    if [ ! -e "$item" ]; then
      echo "Error: '$item' does not exist"
      return 1
    fi
  done
  
  case "$FILE" in
    *.tar.bz2|*.tbz2) tar cvjf "$FILE" "$@" ;;
    *.tar.gz|*.tgz)   tar cvzf "$FILE" "$@" ;;
    *.tar)            tar cvf "$FILE" "$@" ;;
    *.zip)            zip -r "$FILE" "$@" ;;
    *.rar)            rar a "$FILE" "$@" ;;
    *.7z)             7z a "$FILE" "$@" ;;
    *)                echo "'$FILE' format not supported" ;;
  esac
}

# Archives - Extract
.fn:a:x () {

  if [ $# -lt 1 ]
  then
    echo Usage: extract file
    return 1
  fi
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xvjf $1    ;;
      *.tar.gz)    tar xvzf $1    ;;
      *.bz2)       bunzip2 $1     ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1      ;;
      *.tar)       tar xvf $1     ;;
      *.tbz2)      tar xvjf $1    ;;
      *.tgz)       tar xvzf $1    ;;
      *.zip)       unzip $1       ;;
      *.war|*.jar) unzip $1       ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1        ;;
      *)           echo "don't know how to extract '$1'..." ;;
    esac
  else
    echo "'$1' is not a valid file!"
  fi

}

# Files/Folders: Make folder and enter
.fn:d (){

  if [ -f "$1" ] ; then
    echo "File $1 exists~"
    return
  fi
  if [ ! -d "$1" ] ;then
    mkdir -p "$1"
    cd "$1"
  else
    echo "$1 exists~"
  fi

}

# Git - config
.fn:g:cnf () {

  git config --global user.name "$1" && git config --global user.email "$2"

}

# Git - link local repo to remote origin
.fn:g:ro () {

  git remote add origin "$1" && git branch -M main && git push -u origin main

}

# Git: Revert both the local and remote to a previous working commit.
.fn:g:rv ()
{

  git reset --hard $1 && git clean -f && git push -f origin $2

}

# Git: What changed in the last X days?
.fn:g:wch ()
{

  git whatchanged --abbrev-commit --since="$1"

}


# Git: Identify all untracked remote branches.
.fn:g:br () {
  
  remote=origin;

  # Get all remote branches
  remote_branches=$(git branch -r | grep $remote | grep -v /main | grep -v /HEAD | awk '{gsub(/^[^\/]+\//,"",$1); print $1}')
  
  # Get all locally tracked branches
  tracked_branches=$(git branch -vv | grep "\[$remote" | awk '{print $1}')
  
  echo -e 'Remote branches not tracked locally:'
  echo -e '-----------------------------------\n'
  
  found_untracked=false
  
  for brname in $remote_branches; do
    # Check if branch is already tracked locally
    if ! echo "$tracked_branches" | grep -q "^$brname$"; then
      echo "$brname:"
      echo "  git branch --track $brname $remote/$brname"
      found_untracked=true
    fi
  done
  
  if [ "$found_untracked" = false ]; then
    echo "All remote branches are already tracked locally."
  fi

}

# Git: create local tracking branches for all untracked remote branches.
.fn:g:br. () {

  remote=origin;

  # Get all remote branches
  remote_branches=$(git branch -r | grep $remote | grep -v /main | grep -v /HEAD | awk '{gsub(/^[^\/]+\//,"",$1); print $1}')
    
  for brname in $remote_branches; do
    # Check if branch already exists locally   
    if ! git show-ref -q --heads $brname; then
      echo "Tracking remote branch: $brname"
      git branch --track $brname $remote/$brname && git pull;
    else
      echo "Branch $brname already exists locally."
    fi
  done
}



# Git: Find files in the repository that are redundant and not referenced anywhere in the application's code.
.fn:g:clean () {

  # Loop through all files in the specified directory
  for FILE in $(git ls-files ./$1); do
      # Check if the file is referenced anywhere in the application's code
      git grep $(basename "$FILE") > /dev/null || echo "$FILE is not referenced anywhere in the application's code and can probably be removed."
  done

}

# Git: Delete stale branches that have already been merged into the main branch.
.fn:g:clean:br () {

  for k in $(git branch --format="%(refname:short)" --merged main); do
    if [[ $(git log -1 --since='9 months ago' -s $k |wc -l)==0 ]]; then
      git log -1 --date=relative --oneline --pretty="%C(red)[Date: %ad]%C(cyan) <=> Last Commit: %C(yellow)%s" $k
    fi
  done

}

# Function to manage git stashes
function gstash() {
    action=$1
    case "$action" in
        "s") git stash ;;
        "a") git stash apply ;;
        "c") git stash clear ;;
        "l") git stash list ;;
        *) echo "Invalid action. Available actions: 's' <=> save, 'a' <=> apply, 'c' <=> clear, 'l' <=> list" ;;
    esac
}

# Function to manage git remotes
function gremote() {
    action=$1
    case "$action" in
        "v") git remote -v ;;
        "a") git remote add origin ;;
        "p") git remote prune origin ;;
        "r") git remote remove origin ;;
        *) echo "Invalid action. Available actions: 'v' <=> show, 'a' <=> add, 'p' <=> prune, 'r' <=> remove" ;;
    esac
}

function gbranch() {
  local branch_name="$1"
  local remote_branch="${2:-local}" # Default to local if not specified

  if [ -z "$branch_name" ]; then
    echo "Usage: g:bn <branch_name> [remote_branch (default: local)]"
    return 1
  fi

  git checkout -b "$branch_name"

  if [ "$remote_branch" != "local" ]; then
    git push origin "HEAD:$branch_name"
    git branch --set-upstream-to=origin/"$branch_name" "$branch_name"
  fi
}

function f:c:mp4() {
    for input_file in *.mov; do
        if [ -f "$input_file" ]; then
            output_file="${input_file%.mov}.mp4"
            ffmpeg -i "$input_file" -c:v libx264 -c:a aac -vf format=yuv420p -movflags +faststart "$output_file"
        fi
    done
}
