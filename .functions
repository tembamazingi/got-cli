# List all custom functions
.fn () {

  print -l ${(ok)functions[(I).*]}

}
# Archives - create new
.fn:a () {
  if [ "$#" -lt 2 ] ; then
    echo "usage: .fn:a [archive_file] [files/folders...]"
    return 1
  fi

  FILE="$1"
  shift

  # Check if source files exist
  for item in "$@"; do
    if [ ! -e "$item" ]; then
      echo "Error: '$item' does not exist"
      return 1
    fi
  done

  case "$FILE" in
    *.tar.bz2|*.tbz2) tar cvjf "$FILE" "$@" ;;
    *.tar.gz|*.tgz)   tar cvzf "$FILE" "$@" ;;
    *.tar)            tar cvf "$FILE" "$@" ;;
    *.zip)            zip -r "$FILE" "$@" ;;
    *.rar)            rar a "$FILE" "$@" ;;
    *.7z)             7z a "$FILE" "$@" ;;
    *)                echo "'$FILE' format not supported" ;;
  esac
}

# Archives - Extract
.fn:a:x () {

  if [ $# -lt 1 ]
  then
    echo Usage: extract file
    return 1
  fi
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xvjf $1    ;;
      *.tar.gz)    tar xvzf $1    ;;
      *.bz2)       bunzip2 $1     ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1      ;;
      *.tar)       tar xvf $1     ;;
      *.tbz2)      tar xvjf $1    ;;
      *.tgz)       tar xvzf $1    ;;
      *.zip)       unzip $1       ;;
      *.war|*.jar) unzip $1       ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1        ;;
      *)           echo "don't know how to extract '$1'..." ;;
    esac
  else
    echo "'$1' is not a valid file!"
  fi

}

# Files/Folders: Make folder and enter
.fn:d (){

  if [ -f "$1" ] ; then
    echo "File $1 exists~"
    return
  fi
  if [ ! -d "$1" ] ;then
    mkdir -p "$1"
    cd "$1"
  else
    echo "$1 exists~"
  fi

}

# Git - config
.fn:g:cnf () {

  git config --global user.name "$1" && git config --global user.email "$2"

}

# Git - link local repo to remote origin
.fn:g:ro () {

  git remote add origin "$1" && git branch -M main && git push -u origin main

}

# Git: Revert both the local and remote to a previous working commit.
.fn:g:rv ()
{

  git reset --hard $1 && git clean -f && git push -f origin $2

}

# Git: What changed in the last X days?
.fn:g:wch ()
{

  git whatchanged --abbrev-commit --since="$1"

}


# Git: create local tracking branches for all untracked remote branches.
.fn:g:br. () {

  remote=origin;

  # Get all remote branches
  remote_branches=$(git branch -r | grep $remote | grep -v /main | grep -v /HEAD | awk '{gsub(/^[^\/]+\//,"",$1); print $1}')

  for brname in $remote_branches; do
    # Check if branch already exists locally
    if ! git show-ref -q --heads $brname; then
      echo "Tracking remote branch: $brname"
      git branch --track $brname $remote/$brname
      echo "Checking out and pulling branch: $brname"
      git checkout $brname && git pull
    else
      echo "Branch $brname already exists locally."
    fi
  done

  # Return to master branch
  echo "Returning to master branch"
  git checkout master
}

# Git: Find files in the repository that are redundant and not referenced anywhere in the application's code.
.fn:g:clean () {

  # Loop through all files in the specified directory
  for FILE in $(git ls-files ./$1); do
      # Check if the file is referenced anywhere in the application's code
      git grep $(basename "$FILE") > /dev/null || echo "$FILE is not referenced anywhere in the application's code and can probably be removed."
  done

}

# Git: Delete stale branches that have already been merged into the main branch.
.fn:g:clean:br () {

  for k in $(git branch --format="%(refname:short)" --merged main); do
    if [[ $(git log -1 --since='9 months ago' -s $k |wc -l)==0 ]]; then
      git log -1 --date=relative --oneline --pretty="%C(red)[Date: %ad]%C(cyan) <=> Last Commit: %C(yellow)%s" $k
    fi
  done

}

# Function to manage git stashes
function gstash() {
    action=$1
    case "$action" in
        "s") git stash ;;
        "a") git stash apply ;;
        "p") git stash pop ;;
        "c") git stash clear ;;
        "l") git stash list ;;
        *) echo "Invalid action. Available actions: 's' <=> save, 'a' <=> apply, 'p' <=> pop, 'c' <=> clear, 'l' <=> list" ;;
    esac
}

# Function to manage git remotes
function gremote() {
    action=$1
    case "$action" in
        "v") git remote -v ;;
        "a") git remote add origin ;;
        "p") git remote prune origin ;;
        "r") git remote remove origin ;;
        *) echo "Invalid action. Available actions: 'v' <=> show, 'a' <=> add, 'p' <=> prune, 'r' <=> remove" ;;
    esac
}

function gbranch() {
  local branch_name="$1"
  local remote_branch="${2:-local}" # Default to local if not specified

  if [ -z "$branch_name" ]; then
    echo "Usage: g:bn <branch_name> [remote_branch (default: local)]"
    return 1
  fi

  git checkout -b "$branch_name"

  if [ "$remote_branch" != "local" ]; then
    git push origin "HEAD:$branch_name"
    git branch --set-upstream-to=origin/"$branch_name" "$branch_name"
  fi
}

# Convert a single video file between formats: .mov to .mp4 or .mov to .gif
function .fn:m:cnv() {
    if [ $# -ne 2 ]; then
        echo "Usage: .fn:media:c [input.mov] [mp4|gif]"
        return 1
    fi

    input_file="$1"
    target_format="$2"

    if [ ! -f "$input_file" ]; then
        echo "Input file not found: $input_file"
        return 1
    fi

    case "$target_format" in
        mp4)
            output_file="${input_file%.mov}.mp4"
            ffmpeg -i "$input_file" -c:v libx264 -c:a aac -vf format=yuv420p -movflags +faststart "$output_file"
            ;;
        gif)
            output_file="${input_file%.mov}.gif"
            # Generate a palette for better quality GIFs
            palette="/tmp/palette.png"
            ffmpeg -y -i "$input_file" -vf fps=10,scale=480:-1:flags=lanczos,palettegen "$palette"
            ffmpeg -i "$input_file" -i "$palette" -filter_complex "fps=10,scale=480:-1:flags=lanczos[x];[x][1:v]paletteuse" "$output_file"
            rm -f "$palette"
            ;;
        *)
            echo "Unsupported target format: $target_format"
            echo "Supported formats: mp4, gif"
            return 1
            ;;
    esac
}

# Port management: view/kill/force kill processes running on a specified port
function .fn:pm() {
    if [ -z "$1" ]; then
        echo "Usage: .fn:pm <port_number> [action]"
        echo "Actions:"
        echo "  c  - Just check what's running (default)"
        echo "  k  - Kill with confirmation"
        echo "  z  - Force kill without confirmation"
        echo "  d  - Debug mode (shows detailed information)"
        echo ""
        echo "Examples:"
        echo "  .fn:pm 3000"
        echo "  .fn:pm 3000 c"
        echo "  .fn:pm 3000 k"
        echo "  .fn:pm 3000 z"
        return 1
    fi

    local port=$1
    local action=${2:-c}
    local debug=false

    # Enable debug mode if requested
    if [ "$action" = "d" ]; then
        debug=true
        action="c"
    fi

    # Validate port number
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        echo "‚ùå Error: Invalid port number '$port'. Must be between 1-65535."
        return 1
    fi

    # Check if lsof is available
    if ! command -v lsof &> /dev/null; then
        echo "‚ùå Error: lsof command not found. Please install it first."
        return 1
    fi

    echo "üîç Checking port $port..."

    # Find processes using the port with better error handling
    local pids_raw=$(lsof -ti:$port 2>/dev/null)

    if [ "$debug" = true ]; then
        echo "DEBUG: Raw lsof output: '$pids_raw'"
        echo "DEBUG: lsof command: lsof -ti:$port"
    fi

    if [ -z "$pids_raw" ]; then
        echo "‚úÖ No process found running on port $port"
        return 0
    fi

    # Clean and validate PIDs
    local pids=()
    while read -r pid; do
        if [[ "$pid" =~ ^[0-9]+$ ]] && [ "$pid" -gt 0 ]; then
            pids+=("$pid")
        elif [ "$debug" = true ]; then
            echo "DEBUG: Skipping invalid PID: '$pid'"
        fi
    done <<< "$pids_raw"

    if [ ${#pids[@]} -eq 0 ]; then
        echo "‚ùå No valid process IDs found for port $port"
        return 1
    fi

    if [ "$debug" = true ]; then
        echo "DEBUG: Valid PIDs found: ${pids[*]}"
        echo "DEBUG: Number of processes: ${#pids[@]}"
    fi

    # Display process information
    echo "üîç Process(es) found on port $port:"
    echo "----------------------------------------"
    lsof -i:$port 2>/dev/null || echo "Error displaying process details"
    echo "----------------------------------------"

    # Handle different actions
    case $action in
        "c")
            echo "‚ÑπÔ∏è  Use '.fn:pm $port k' to terminate these processes"
            if [ "$debug" = true ]; then
                echo "DEBUG: Would attempt to kill PIDs: ${pids[*]}"
            fi
            ;;
        "k"|"z")
            local killed_count=0
            local total_count=${#pids[@]}

            echo "üéØ Attempting to terminate $total_count process(es)..."

            for pid in "${pids[@]}"; do
                if [ "$debug" = true ]; then
                    echo "DEBUG: Processing PID $pid"
                fi

                # Verify process still exists
                if ! kill -0 "$pid" 2>/dev/null; then
                    echo "‚ö†Ô∏è  Process $pid no longer exists"
                    continue
                fi

                # Get process info with better error handling
                local process_info=$(ps -p "$pid" -o user=,comm= 2>/dev/null)
                if [ -z "$process_info" ]; then
                    echo "‚ö†Ô∏è  Cannot get info for process $pid (may have died)"
                    continue
                fi

                local process_user=$(echo "$process_info" | awk '{print $1}' | tr -d ' ')
                local process_name=$(echo "$process_info" | awk '{print $2}' | tr -d ' ')
                local current_user=$(whoami)

                if [ "$debug" = true ]; then
                    echo "DEBUG: PID=$pid, User=$process_user, Name=$process_name, CurrentUser=$current_user"
                fi

                echo "üìã Process $pid: $process_name (owner: $process_user)"

                # Check permissions
                local needs_sudo=false
                if [ "$process_user" != "$current_user" ] && [ "$current_user" != "root" ]; then
                    echo "‚ö†Ô∏è  Warning: Process $pid is owned by $process_user, not $current_user"
                    needs_sudo=true
                fi

                # Ask for confirmation if action is 'k'
                local proceed=true
                if [ "$action" = "k" ]; then
                    echo -n "‚ùì Terminate process $pid ($process_name)? [y/N]: "
                    read -r reply
                    if [ "$debug" = true ]; then
                        echo "DEBUG: User reply: '$reply'"
                    fi

                    if [[ ! "$reply" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                        echo "‚è≠Ô∏è  Skipping process $pid"
                        proceed=false
                    fi
                fi

                if [ "$proceed" = true ]; then
                    echo "üîÑ Terminating process $pid ($process_name)..."

                    # Try graceful termination first
                    local success=false

                    # Attempt 1: Regular SIGTERM
                    if [ "$debug" = true ]; then
                        echo "DEBUG: Attempting SIGTERM on PID $pid"
                    fi

                    if kill "$pid" 2>/dev/null; then
                        echo "   ‚úì Sent SIGTERM to process $pid"
                        sleep 3  # Give more time for graceful shutdown

                        if ! kill -0 "$pid" 2>/dev/null; then
                            echo "‚úÖ Process $pid terminated successfully"
                            success=true
                            killed_count=$((killed_count + 1))
                        fi
                    fi

                    # Attempt 2: Regular SIGKILL if still running
                    if [ "$success" = false ] && kill -0 "$pid" 2>/dev/null; then
                        if [ "$debug" = true ]; then
                            echo "DEBUG: Process still running, attempting SIGKILL"
                        fi

                        echo "üîÑ Process still running, force killing..."
                        if kill -9 "$pid" 2>/dev/null; then
                            echo "   ‚úì Sent SIGKILL to process $pid"
                            sleep 2

                            if ! kill -0 "$pid" 2>/dev/null; then
                                echo "‚úÖ Process $pid forcefully terminated"
                                success=true
                                killed_count=$((killed_count + 1))
                            fi
                        fi
                    fi

                    # Attempt 3: Sudo SIGTERM if regular kill failed
                    if [ "$success" = false ] && kill -0 "$pid" 2>/dev/null; then
                        if [ "$debug" = true ]; then
                            echo "DEBUG: Attempting sudo SIGTERM"
                        fi

                        echo "üîê Attempting termination with elevated privileges..."
                        if sudo kill "$pid" 2>/dev/null; then
                            echo "   ‚úì Sent SIGTERM to process $pid (with sudo)"
                            sleep 3

                            if ! kill -0 "$pid" 2>/dev/null; then
                                echo "‚úÖ Process $pid terminated successfully (with sudo)"
                                success=true
                                killed_count=$((killed_count + 1))
                            fi
                        fi
                    fi

                    # Attempt 4: Sudo SIGKILL as last resort
                    if [ "$success" = false ] && kill -0 "$pid" 2>/dev/null; then
                        if [ "$debug" = true ]; then
                            echo "DEBUG: Attempting sudo SIGKILL as last resort"
                        fi

                        echo "üîÑ Process still running, force killing with sudo..."
                        if sudo kill -9 "$pid" 2>/dev/null; then
                            echo "   ‚úì Sent SIGKILL to process $pid (with sudo)"
                            sleep 2

                            if ! kill -0 "$pid" 2>/dev/null; then
                                echo "‚úÖ Process $pid forcefully terminated (with sudo)"
                                success=true
                                killed_count=$((killed_count + 1))
                            else
                                echo "‚ùå Failed to terminate process $pid (process may be unkillable)"
                            fi
                        else
                            echo "‚ùå Failed to kill process $pid even with sudo"
                        fi
                    fi
                fi
            done

            # Final verification and summary
            echo ""
            echo "üìä Summary: Successfully terminated $killed_count out of $total_count processes"
            echo ""
            echo "üîç Final verification:"
            local remaining=$(lsof -ti:$port 2>/dev/null)
            if [ -z "$remaining" ]; then
                echo "‚úÖ Port $port is now free!"
            else
                echo "‚ö†Ô∏è  Some processes still running on port $port:"
                lsof -i:$port 2>/dev/null
                echo ""
                echo "üí° Tip: Some processes may be unkillable if they're in an uninterruptible state"
                echo "   Try '.fn:pm $port d' for debug information"
            fi
            ;;
        *)
            echo "‚ùå Unknown action: '$action'"
            echo "Valid actions: c (check), k (kill with confirmation), z (force kill), d (debug)"
            return 1
            ;;
    esac
}
